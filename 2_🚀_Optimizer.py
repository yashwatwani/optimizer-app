import streamlit as st
import pandas as pd
import numpy as np
import calendar
from scipy.optimize import minimize
import plotly.graph_objects as go
import math # Import math for isnan check

# ---------------------------
# FILE PATHS
# ---------------------------
# NOTE: These files must exist in the expected path (e.g., in a 'data' folder
# relative to where the script is run) for the application to load data.
OPTIMIZER_FILE_PATH = "data/optimiser_df.xlsx"
ROAS_FILE_PATH = "data/ROAS Data Frame.xlsx"

# ---------------------------
# HELPER FUNCTIONS
# ---------------------------
def calculate_channel_revenue(spend, df):
    """
    Calculates the revenue generated by a channel based on the spend,
    using the provided coefficient and alpha values.
    Uses the adstock/saturation-based response function: 
    Revenue = Coeff * Base ^ (Alpha ^ (100 * Spend / Max_Spend))
    """
    coeff = df['Coefficient'].values
    alpha = df['Alpha'].values
    max_spend = df['Max Spend'].values
    
    # Safely handle max_spend=0 to avoid division by zero.
    # Use a small epsilon (1e-6) only where max_spend is zero.
    safe_max_spend = np.where(max_spend == 0, 1e-6, max_spend)
    
    # Base is a small constant (0.05 / 10**10) to ensure the power function 
    # results in a low value when the exponent is near 1 (low spend) 
    # and a high value (near 1) when the exponent is small (high spend).
    base = 0.05 / 10**10
    
    with np.errstate(over='ignore', divide='ignore', invalid='ignore'):
        # Calculate the ratio term (100 * Spend / Max_Spend)
        ratio_term = 100.0 * spend / safe_max_spend
        # Calculate the power term (Alpha ^ Ratio_Term)
        power_term = np.power(alpha, ratio_term)
        # Calculate the revenue factor (Base ^ Power_Term)
        revenue_factor = np.power(base, power_term)
    
    # Handle NaNs and Infs that might arise from large power operations
    revenue_factor = np.nan_to_num(revenue_factor, nan=0.0, posinf=0.0, neginf=0.0)
    
    # Total Revenue
    return coeff * revenue_factor

def objective_function(daily_spend_allocations, df):
    """The function to minimize (negative of total revenue)."""
    # We want to maximize revenue, so we minimize the negative revenue.
    total_daily_revenue = np.sum(calculate_channel_revenue(daily_spend_allocations, df))
    return -total_daily_revenue

def constraint_budget(daily_spend_allocations, daily_budget_input):
    """Constraint: Total spend must be less than or equal to the daily budget."""
    # constraint >= 0, so daily_budget_input - sum(spend) >= 0
    return daily_budget_input - np.sum(daily_spend_allocations)

@st.cache_data
def load_optimizer_data(file_path):
    """Load the main data frame used for optimization."""
    try:
        return pd.read_excel(file_path)
    except Exception as e:
        st.error(f"Error loading optimizer data: {e}")
        return pd.DataFrame()

@st.cache_data
def load_roas_data(file_path):
    """Load ROAS data from all port sheets for plotting response curves."""
    try:
        xls = pd.ExcelFile(file_path)
        sheet_names = xls.sheet_names
        all_data = []
        # Load all sheets and concatenate them
        for sheet in sheet_names:
            df = pd.read_excel(xls, sheet_name=sheet)
            df["Port"] = sheet
            all_data.append(df)
        return pd.concat(all_data, ignore_index=True)
    except Exception as e:
        st.error(f"Error loading ROAS data: {e}")
        return pd.DataFrame()

def plot_response_curves(roas_df, num_days, df_opt_month, daily_optimal_spend):
    """
    Plot Total Cost vs Total Revenue response curves for all channels 
    and adds the optimized budget points (black dots) without labels or a legend entry.
    """
    if roas_df.empty:
        st.warning("ROAS data not found for plotting.")
        return
        
    month_selected = df_opt_month["Month"].iloc[0]
    roas_df_month = roas_df[roas_df["Month"] == month_selected]
    
    if roas_df_month.empty:
        st.warning(f"No ROAS data for month {month_selected} for plotting.")
        return
        
    # Multiply daily cost/revenue by number of days to get campaign totals
    roas_df_month = roas_df_month.copy() # Avoid SettingWithCopyWarning
    roas_df_month["Total Cost"] = roas_df_month["Total Cost"] * num_days
    roas_df_month["Total Revenue"] = roas_df_month["Total Revenue"] * num_days
    
    fig = go.Figure()
    
    # Mapping from sheet names to Port_Channel prefixes for legend names
    port_mapping = {
        "Chicago": "Chicago",
        "New York": "NY",
        "San Diego": "SD"
    }
    
    # Plot lines for each Port-Channel
    for port in ["Chicago", "New York", "San Diego"]:
        for channel in ["Google", "Meta"]:
            subset = roas_df_month[(roas_df_month["Port"] == port) &
                                   (roas_df_month["Channel"] == channel)]
            if subset.empty:
                continue
            fig.add_trace(go.Scatter(
                x=subset["Total Cost"],
                y=subset["Total Revenue"],
                mode="lines",
                name=f"{port_mapping[port]}_{channel}",
                line=dict(width=2)
            ))
            
    # Add dots for optimized allocations (black dots)
    optimal_df = df_opt_month.copy()
    optimal_df["Optimal Spend"] = daily_optimal_spend * num_days
    # Calculate campaign revenue from optimal daily spend
    optimal_revenue_daily = calculate_channel_revenue(daily_optimal_spend, df_opt_month)
    optimal_df["Optimal Revenue"] = optimal_revenue_daily * num_days
    
    for i, row in optimal_df.iterrows():
        # Check if the spend is zero or not a number before plotting
        if row["Optimal Spend"] > 0 and not math.isnan(row["Optimal Spend"]):
            fig.add_trace(go.Scatter(
                x=[row["Optimal Spend"]],
                y=[row["Optimal Revenue"]],
                mode="markers", # CHANGED: Set mode to 'markers' only (removes text label)
                name=f"{row['Port_Channel']} (Optimized)",
                marker=dict(size=10, color="black", symbol="circle"),
                showlegend=False # CHANGED: Hide this trace from the legend
            ))

    fig.update_layout(
        #title=f"ðŸ“ˆ Response Curves & Optimized Budgets for {month_selected}",
        xaxis_title="Total Cost (USD)",
        yaxis_title="Total Revenue (USD)",
        template="plotly_white",
        height=600,
        legend=dict(orientation="h", yanchor="bottom", y=1.02,
                    xanchor="center", x=0.5)
    )
    
    #st.markdown("#### ðŸ“Š Response Curves with Optimized Budgets")
    st.plotly_chart(fig, use_container_width=True)

# ---------------------------
# STREAMLIT APP
# ---------------------------
def app_optimizer():
    st.set_page_config(layout="wide")
    st.title("ðŸš€ Media Spend Optimizer")

    # Load optimizer data
    df_opt = load_optimizer_data(OPTIMIZER_FILE_PATH)
    if df_opt.empty:
        st.error(f"Cannot run optimization. Please ensure the data file '{OPTIMIZER_FILE_PATH}' is available and not empty.")
        return

    # --- Sidebar for Inputs ---
    available_months = sorted(df_opt["Month"].dropna().unique())
    selected_month = st.sidebar.selectbox("ðŸ“… Select Month for Planning", available_months)

    df_opt_month = df_opt[df_opt["Month"] == selected_month].reset_index(drop=True)
    if df_opt_month.empty:
        st.warning(f"No data found for month: {selected_month}")
        return

    st.sidebar.markdown("---")
    
    st.sidebar.header("1ï¸âƒ£ Select Campaign Duration")

    # Get number of days in the selected month (assuming a non-leap year 2025)
    month_num = 1 # Default
    try:
        month_num = list(calendar.month_name).index(selected_month.capitalize())
    except ValueError:
        try:
             # Try abbreviation mapping if name failed
            month_abbrev_to_num = {v.lower(): k for k, v in enumerate(calendar.month_abbr) if v}
            month_num = month_abbrev_to_num.get(selected_month.lower(), 1)
        except:
             # Fallback if all else fails
             pass

    days_in_month = calendar.monthrange(2025, month_num)[1]
    
    # Use linked slider and number input
    col1, col2 = st.sidebar.columns([3, 1])
    with col1:
        num_days_slider = st.slider(
            "Number of Days in Campaign",
            min_value=1,
            max_value=days_in_month,
            value=min(30, days_in_month),
            step=1,
            key="days_slider",
            help=f"Select number of campaign days (max {days_in_month})."
        )
    with col2:
        num_days_input = st.number_input(
            "Or type days",
            min_value=1,
            max_value=days_in_month,
            value=num_days_slider,
            step=1,
            key="days_input",
            label_visibility="collapsed"
        )
        
    num_days = num_days_input

    st.sidebar.header("2ï¸âƒ£ Select Total Campaign Budget")
    
    # Calculate min/max budgets based on daily constraints
    min_daily_budget = df_opt_month['Min_constraint'].sum()
    max_daily_budget = df_opt_month['Max_constraint'].sum()

    min_total_budget = int(min_daily_budget * num_days)
    max_total_budget = int(max_daily_budget * num_days)

    colb1, colb2 = st.sidebar.columns([3, 1])
    with colb1:
        total_budget_slider = st.slider(
            "Total Budget (USD)",
            min_value=min_total_budget,
            max_value=max_total_budget,
            # Set a default value safely within the min/max range
            value=int(min(max_total_budget, max(min_total_budget, (min_total_budget + max_total_budget) / 2))),
            step=1000,
            format="%d",
            key="budget_slider"
        )
    with colb2:
        total_budget_input = st.number_input(
            "Or type budget",
            min_value=min_total_budget,
            max_value=max_total_budget,
            value=total_budget_slider,
            step=1000,
            key="budget_input",
            label_visibility="collapsed"
        )

    total_campaign_budget = total_budget_input
    daily_budget = total_campaign_budget / num_days if num_days > 0 else 0
    
    # --- Run Optimization ---
    
    # Initial guess for daily spend (using the 'Avg' column from the data)
    x0 = df_opt_month['Avg'].values
    
    # Bounds for each channel's daily spend (Min_constraint to Max_constraint)
    bounds = [(df_opt_month['Min_constraint'].iloc[i], df_opt_month['Max_constraint'].iloc[i])
              for i in range(len(df_opt_month))]
              
    # Constraint: Total daily spend <= Daily Budget
    constraints = [{'type': 'ineq', 'fun': constraint_budget, 'args': (daily_budget,)}]

    st.markdown("---")

    # Only run optimization if the daily budget is positive
    if daily_budget <= 0:
        st.warning("Please select a campaign budget greater than $0 to run the optimization.")
        return

    with st.spinner(f"Optimizing daily spend for {num_days} days ({selected_month}) with a budget of ${total_campaign_budget:,.0f}..."):
        try:
            result = minimize(
                fun=objective_function,
                x0=x0,
                args=(df_opt_month,),
                method='SLSQP',
                bounds=bounds,
                constraints=constraints,
                options={'disp': False, 'maxiter': 1000}
            )
        except Exception as e:
            st.error(f"Optimization failed due to an unexpected error: {e}")
            return

    st.header(f"ðŸ“Š Optimization Results for {selected_month}")

    if result.success:
        daily_optimal_spend = result.x
        daily_optimal_revenue = -result.fun
        
        # Calculate campaign totals
        campaign_optimal_spend = daily_optimal_spend * num_days
        campaign_optimal_revenue = daily_optimal_revenue * num_days
        
        # Calculate overall ROAS
        total_spend_optimized = campaign_optimal_spend.sum()
        total_roas = (campaign_optimal_revenue / total_spend_optimized
                      if total_spend_optimized > 0 else 0)
                      
        # Adjusting the actual spend to match the total budget if the optimizer didn't use it all
        # (Usually, SLSQP is precise, but for metrics, we use the actual sum)
        
        #st.success("âœ… Optimization Successful! Achieving maximum possible revenue.")

        # --- Metrics Display ---
        col_a, col_b, col_c = st.columns(3)
        col_a.metric("Max Revenue", f"${campaign_optimal_revenue:,.0f}")
        col_b.metric("Optimized Spend", f"${total_spend_optimized:,.0f}")
        col_c.metric("Campaign ROAS", f"{total_roas:.2f}")

        # --- Detailed Allocation Table ---
        results_df = df_opt_month[['Port_Channel']].copy()
        results_df['Optimal Spend (Campaign)'] = campaign_optimal_spend
        
        # Calculate campaign revenue for each channel
        optimal_revenue_per_channel_daily = calculate_channel_revenue(daily_optimal_spend, df_opt_month)
        results_df['Revenue from Optimal Spend (Campaign)'] = optimal_revenue_per_channel_daily * num_days
        
        # Calculate Channel ROAS
        roas_safe_spend = np.where(results_df['Optimal Spend (Campaign)'] == 0, 1e-6, results_df['Optimal Spend (Campaign)'])
        results_df['Channel ROAS'] = results_df['Revenue from Optimal Spend (Campaign)'] / roas_safe_spend
        
        # Format columns for display
        results_df['Optimal Spend (Campaign)'] = results_df['Optimal Spend (Campaign)'].map('${:,.0f}'.format)
        results_df['Revenue from Optimal Spend (Campaign)'] = results_df['Revenue from Optimal Spend (Campaign)'].map('${:,.0f}'.format)
        results_df['Channel ROAS'] = results_df['Channel ROAS'].map('{:.2f}'.format)

        st.markdown("#### Optimal Spend Allocation by Channel:")
        st.dataframe(results_df, use_container_width=True, hide_index=True)

        # --- Plot combined ROAS curves with optimized points ---
        roas_df = load_roas_data(ROAS_FILE_PATH)
        if not roas_df.empty:
             plot_response_curves(roas_df, num_days, df_opt_month, daily_optimal_spend)
        else:
             st.warning("Response curve plot cannot be generated as ROAS data is missing.")

    else:
        st.error(f"Optimization Failed. The solver could not find a solution. Reason: {result.message}")

# ---------------------------
# RUN APP
# ---------------------------
if __name__ == "__main__":
    app_optimizer()
